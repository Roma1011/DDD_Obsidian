პირველი, რაც დავინახე კარში შესვლისას, იყო სრული კლასების დიაგრამა, დაბეჭდილი დიდ ფურცლებზე, რომლებიც მთელ კედელს ფარავდა. ეს იყო ჩემი პირველი დღე პროექტზე, სადაც ჭკვიანმა ადამიანებმა თვეები გაატარეს დომენის დეტალური მოდელის კვლევასა და განვითარებაში. მოდელის ტიპურ ობიექტს ჰქონდა რთული კავშირები სამ ან ოთხ სხვა ობიექტთან, და ეს კავშირების ქსელი თითქმის არ ჰქონდა ბუნებრივ საზღვრებს. ამ მხრივ, ანალიტიკოსები ერთგულები იყვნენ დომენის ბუნების მიმართ.

მიუხედავად იმისა, რომ კედლის ზომის დიაგრამა შთამბეჭდავი იყო, მოდელმა მართლაც შეიცავა გარკვეული ცოდნა. ზომიერი შესწავლის შემდეგ, მე ბევრი რამ ვისწავლე (თუმცა ეს სწავლა ძნელი მისამართი იყო — ისევე, როგორც ვებში შემთხვევითი დათვალიერება). უფრო მეტად მაწუხებდა ის, რომ ჩემი შესწავლა არანაირ ხედვას არ მაძლევდა აპლიკაციის კოდსა და დიზაინზე.

როდესაც დეველოპერებმა დაიწყეს აპლიკაციის განხორციელება, მათ სწრაფად აღმოაჩინეს, რომ კავშირების ეს ქაოსი, თუმცა ადამიანისთვის გასაგები იყო, არ ითარგმნებოდა შესანახ, ამოღებად ერთეულებად, რომლებიც ტრანზაქციული მთლიანობით შეიძლებოდა მანიპულირებულიყო. გაითვალისწინეთ, რომ ეს პროექტი იყენებდა ობიექტურ მონაცემთა ბაზას, ამიტომ დეველოპერებს არც კი უწევდათ ობიექტების რელაციურ ცხრილებში გადაყვანის გამოწვევასთან გამკლავება. ფუნდამენტურ დონეზე, მოდელი არ იძლეოდა განხორციელების სახელმძღვანელოს.

ვინაიდან მოდელი „სწორი“ იყო, ტექნიკურ ანალიტიკოსებსა და ბიზნეს ექსპერტებს შორის ვრცელი თანამშრომლობის შედეგი, დეველოპერებმა მივიდნენ დასკვნამდე, რომ კონცეპტუალურად დაფუძნებული ობიექტები ვერ იქნებოდა მათი დიზაინის საფუძველი. ამიტომ, მათ შეიმუშავეს ad hoc დიზაინი. მათმა დიზაინმა გამოიყენა რამდენიმე იგივე კლასის სახელი და ატრიბუტი მონაცემთა შესანახად, მაგრამ ის არ ეფუძნებოდა არსებულ, ან ნებისმიერ, მოდელს.

პროექტს ჰქონდა დომენის მოდელი, მაგრამ რა სარგებლობა მოაქვს ქაღალდზე არსებულ მოდელს, თუ ის პირდაპირ არ ეხმარება მოქმედი პროგრამული უზრუნველყოფის განვითარებას?

რამდენიმე წლის შემდეგ, მე ვნახე იგივე საბოლოო შედეგი, რომელიც მთლიანად განსხვავებული პროცესიდან მოვიდა. ეს პროექტი მიზნად ისახავდა არსებული C++ აპლიკაციის ჩანაცვლებას ახალი დიზაინით, განხორციელებული Java-ში. ძველი აპლიკაცია იყო შედგენილი ობიექტების მოდელირებისადმი ყურადღების გარეშე. ძველი აპლიკაციის დიზაინი, თუ საერთოდ ჰქონდა ასეთი, თანდათან გაიზარდა, როდესაც ერთი შესაძლებლობა მეორეს ემატებოდა არსებულ კოდზე, შესამჩნევი განზოგადებისა თუ აბსტრაქციის გარეშე.

უცნაური ის იყო, რომ ორი განსხვავებული პროცესის საბოლოო პროდუქტები ძალიან ჰგავდა ერთმანეთს! ორივეს ჰქონდა ფუნქციონალობა, მაგრამ იყო გაბერილი, ძალიან ძნელად გასაგები, და საბოლოოდ შეუძლებელი შესანარჩუნებლად. მიუხედავად იმისა, რომ განხორციელებებს, ზოგან, ჰქონდა გარკვეული პირდაპირობა, თქვენ ვერ მიიღებდით დიდ ხედვას სისტემის მიზნის შესახებ კოდის კითხვით. არცერთმა პროცესმა არ გამოიყენა ობიექტური პარადიგმის უპირატესობა, რომელიც ხელმისაწვდომი იყო მათი განვითარების გარემოში, გარდა რთული მონაცემთა სტრუქტურებისა.

მოდელები მრავალფეროვანია და მრავალ როლს ასრულებს, თუნდაც ისინი, რომლებიც შემოიფარგლება პროგრამული განვითარების პროექტის კონტექსტით. **დომენზე ორიენტირებული დიზაინი** (Domain-Driven Design) მოითხოვს მოდელს, რომელიც არა მხოლოდ ეხმარება ადრეულ ანალიზს, არამედ თავად არის დიზაინის საფუძველი. ამ მიდგომას აქვს მნიშვნელოვანი გავლენა კოდზე. ნაკლებად აშკარაა ის, რომ დომენზე ორიენტირებული დიზაინი მოითხოვს მოდელირების განსხვავებულ მიდგომას...

### ტეგები

#DDD #DomainDrivenDesign #ModelDrivenDesign #BindingModelAndImplementation #ObjectModeling