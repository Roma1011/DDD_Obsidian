
## შუა საუკუნეების ცის კომპიუტერი

ძველმა ბერძენმა ასტრონომებმა გამოიგონეს ასტროლაბი, რომელიც შუა საუკუნეების ისლამური მეცნიერების მიერ იქნა დახვეწილი. მბრუნავი ქსელი (ე.წ. _rete_) წარმოადგენდა ფიქსირებული ვარსკვლავების პოზიციებს ციურ სფეროზე. ურთიერთჩანაცვლებადი ფირფიტები, რომლებზეც ამოტვიფრული იყო ლოკალური სფერული კოორდინატების სისტემა, წარმოადგენდა სხვადასხვა განედებიდან ხედებს. _Rete_-ს ფირფიტაზე ბრუნვა საშუალებას იძლეოდა გამოეთვალა ციური პოზიციები წლის ნებისმიერი დღისა და დროისთვის. პირიქით, მოცემული ვარსკვლავის ან მზის პოზიციის მიხედვით, შეიძლებოდა დროის გამოთვლა. ასტროლაბი იყო ცის **ობიექტზე ორიენტირებული მოდელის** მექანიკური განხორციელება.

## მოდელის გარეშე პროექტების პრობლემები

პროექტები, რომლებსაც საერთოდ არ აქვთ დომენის მოდელი, არამედ უბრალოდ წერენ კოდს ერთი ფუნქციის მეორის მიყოლებით შესასრულებლად, მცირე სარგებელს იღებენ წინა ორ თავში განხილული ცოდნის დამუშავებისა (_knowledge crunching_) და კომუნიკაციის უპირატესობებიდან. რთული დომენი მათ გადატვირთავს.

მეორე მხრივ, ბევრი რთული პროექტი ცდილობს რაიმე სახის დომენის მოდელის შექმნას, მაგრამ ისინი არ ინარჩუნებენ მჭიდრო კავშირს მოდელსა და კოდს შორის. მათ მიერ შემუშავებული მოდელი, შესაძლოა, სასარგებლო იყოს, როგორც საწყისი კვლევის ინსტრუმენტი, მაგრამ ის სულ უფრო იკარგება  და შეიძლება გახდეს შეცდომაში შემყვანი. მოდელზე გაწეული ყველა ზრუნვა მცირე გარანტიას იძლევა, რომ დიზაინი სწორია, რადგან ისინი განსხვავებულია.

## მოდელისა და განხორციელების გათიშვა

ეს კავშირი შეიძლება მრავალი გზით გაწყდეს, მაგრამ გათიშვა ხშირად შეგნებული არჩევანია. ბევრი დიზაინის მეთოდოლოგია მხარს უჭერს ანალიზის მოდელს, რომელიც საკმაოდ განსხვავდება დიზაინისგან და, როგორც წესი, სხვადასხვა ადამიანების მიერ იქმნება. მას ანალიზის მოდელს უწოდებენ, რადგან ის არის ბიზნეს დომენის ანალიზის პროდუქტი, რომელიც აწესრიგებს მის კონცეფციებს პროგრამულ სისტემაში მისი როლის გათვალისწინების გარეშე. ანალიზის მოდელი განკუთვნილია მხოლოდ გაგებისთვის; განხორციელების საკითხებთან შერევა ითვლება გაუგებრობის მომტანად. მოგვიანებით, იქმნება დიზაინი, რომელსაც შეიძლება მხოლოდ ზოგადი შესაბამისობა ჰქონდეს ანალიზის მოდელთან. ანალიზის მოდელი არ იქმნება დიზაინის საკითხების გათვალისწინებით, ამიტომ ის, სავარაუდოდ, საკმაოდ არაპრაქტიკულია ამ საჭიროებებისთვის.

ანალიზის მოდელი" უბრალოდ იმისთვისაა, რომ ბიზნესი სწორად გავიგოთ. ის **არ** არის იმისთვის, რომ პირდაპირ კოდი დავწეროთ ან არქიტექტურა ავაწყოთ.  
შემდეგ, როცა კარგად გავიგებთ, რაც გვინდა, შევქმნით **დიზაინს** — და ის შეიძლება სრულიად განსხვავდებოდეს ანალიზის მოდელისგან, რადგან დიზაინი უკვე პროგრამირების და განხორციელების მოთხოვნებს ითვალისწინებს.  
ანალიზის მოდელი, თავისთავად, არ არის ოპტიმიზებული კოდის ან სისტემის აშენებისთვის — მხოლოდ გაგებისთვის.

## ცოდნის დაკარგვის რისკი

გარკვეული ცოდნის დამუშავება (_knowledge crunching_) ხდება ასეთი ანალიზის დროს, მაგრამ ამის დიდი ნაწილი იკარგება, როდესაც კოდირება იწყება, რადგან დეველოპერები იძულებულნი ხდებიან შექმნან ახალი აბსტრაქციები დიზაინისთვის. ამ დროს არ არსებობს გარანტია, რომ ანალიტიკოსების მიერ მიღებული ხედვები, რომლებიც მოდელშია ჩადებული, შენარჩუნდება ან ხელახლა იქნება აღმოჩენილი. ამ ეტაპზე, დიზაინსა და ზოგადად დაკავშირებულ მოდელს შორის ნებისმიერი შესაბამისობის შენარჩუნება არაეფექტურია.

## ანალიზის მოდელის ნაკლოვანებები

სუფთა ანალიზის მოდელი ვერ აღწევს თავის მთავარ მიზანს — დომენის გაგებას, რადგან გადამწყვეტი აღმოჩენები ყოველთვის ჩნდება დიზაინის/განხორციელების პროცესში. ყოველთვის ჩნდება ძალიან სპეციფიკური, მოულოდნელი პრობლემები. წინასწარი მოდელი ღრმად იკვლევს ზოგიერთ არააქტუალურ თემას, ხოლო უგულებელყოფს ზოგ მნიშვნელოვან თემას. სხვა თემები წარმოდგენილია ისეთი გზებით, რომლებიც არ არის სასარგებლო აპლიკაციისთვის. შედეგად, სუფთა ანალიზის მოდელები მიატოვებული ხდება კოდირების დაწყებიდან მალევე, და მთელი საფუძველი ხელახლა უნდა განიხილონ. მაგრამ მეორე ეტაპზე, თუ დეველოპერები ანალიზს ცალკე პროცესად აღიქვამენ, მოდელირება ნაკლებად დისციპლინირებულად ხდება. თუ მენეჯერები ანალიზს ცალკე პროცესად აღიქვამენ, განვითარების გუნდს შეიძლება არ მიეცეს დომენის ექსპერტებთან ადეკვატური წვდომა.

ნებისმიერი მიზეზის გამო, პროგრამული უზრუნველყოფა, რომელსაც არ გააჩნია კონცეფცია დიზაინის საფუძვლად, საუკეთესო შემთხვევაში, მხოლოდ მექანიზმია, რომელიც აკეთებს სასარგებლო საქმეებს, მაგრამ არ ხსნის თავის მოქმედებებს.

თუ დიზაინი, ან მისი ზოგიერთი ცენტრალური ნაწილი, არ შეესაბამება დომენის მოდელს, ეს მოდელი მცირე ღირებულებისაა, და პროგრამული უზრუნველყოფის სისწორე საეჭვო ხდება. ამავდროულად, მოდელებსა და დიზაინის ფუნქციებს შორის რთული შესაბამისობები ძნელი გასაგებია და, პრაქტიკაში, შეუძლებელია შენარჩუნება დიზაინის ცვლილებებთან ერთად. ანალიზსა და დიზაინს შორის საშიში უფსკრული იქმნება, რის გამოც თითოეულ ამ აქტივობაში მიღებული ხედვები არ იკვეთება ერთმანეთში.

## მოდელისა და დიზაინის მოთხოვნები

ანალიზმა უნდა აითვისოს დომენის ფუნდამენტური კონცეფციები გასაგებად და გამომხატველად. დიზაინმა უნდა განსაზღვროს კომპონენტების ნაკრები, რომელთა აგებაც შესაძლებელია პროექტში გამოყენებული პროგრამირების ინსტრუმენტებით, რომლებიც ეფექტურად იმუშავებენ სამიზნე განლაგების გარემოში და სწორად გადაჭრიან აპლიკაციისთვის დასმულ პრობლემებს.

**მოდელზე ორიენტირებული დიზაინი** (Model-Driven Design) უარყოფს ანალიზის მოდელისა და დიზაინის დიქოტომიას, რათა მოიძიოს ერთი მოდელი, რომელიც ორივე მიზანს ემსახურება. სუფთა ტექნიკური საკითხების გვერდზე გადადებით, დიზაინის თითოეული ობიექტი თამაშობს კონცეპტუალურ როლს, რომელიც აღწერილია მოდელში. ეს მოითხოვს, რომ უფრო მკაცრი მოთხოვნები დავუწესოთ არჩეულ მოდელს, რადგან მან უნდა შეასრულოს ორი საკმაოდ განსხვავებული მიზანი.

დომენის აბსტრაჰირებისა და აპლიკაციის პრობლემის გადაჭრის მრავალი გზა არსებობს. სწორედ ეს ხდის მოდელისა და დიზაინის შეერთებას პრაქტიკულს. ეს შეერთება არ უნდა მოხდეს ანალიზის შესუსტების ხარჯზე, რაც ტექნიკური მოსაზრებებით ფატალურად იქნება კომპრომეტირებული. ასევე, არ შეიძლება მივიღოთ უხეში დიზაინები, რომლებიც ასახავენ დომენის იდეებს, მაგრამ თავს არიდებენ პროგრამული დიზაინის პრინციპებს. ეს მიდგომა მოითხოვს მოდელს, რომელიც კარგად მუშაობს როგორც ანალიზისთვის, ისე დიზაინისთვის. როდესაც მოდელი არ ჩანს პრაქტიკული განხორციელებისთვის, ჩვენ უნდა მოვძებნოთ ახალი. როდესაც მოდელი ერთგულად არ გამოხატავს დომენის ძირითად კონცეფციებს, ჩვენ უნდა მოვძებნოთ ახალი.

მოდელირებისა და დიზაინის პროცესი ამგვარად ერთიანი იტერაციული ციკლი ხდება. დომენის მოდელის მჭიდროდ დაკავშირება დიზაინთან ამატებს კიდევ ერთ კრიტერიუმს, რომ აირჩიოთ უფრო სასარგებლო მოდელები შესაძლო მოდელების სამყაროდან. ეს მოითხოვს ღრმა ფიქრს, ხშირად მრავალჯერად იტერაციას და დიდ რეფაქტორინგს, მაგრამ ეს მოდელს აქტუალურს ხდის.

## რეკომენდაცია

ამიტომ:

- შეიმუშავეთ პროგრამული სისტემის ნაწილი ისე, რომ ის პირდაპირ ასახავდეს დომენის მოდელს, რათა შესაბამისობა აშკარა იყოს.
- გადახედეთ მოდელს და შეცვალეთ ის ისე, რომ უფრო ბუნებრივად განხორციელდეს პროგრამულად, და ამავდროულად, ეძებეთ გზები, რომ ის ასახავდეს დომენის უფრო ღრმა გაგებას.
- მოითხოვეთ ერთი მოდელი, რომელიც ორივე მიზანს კარგად ემსახურება, გარდა იმისა, რომ მხარს უჭერს მყარ **უნივერსალურ ენას** (Ubiquitous Language).
- გამოიყენეთ მოდელიდან მიღებული ტერმინოლოგია დიზაინში და ძირითადი პასუხისმგებლობების განაწილებაში.

კოდი ხდება მოდელის გამოხატულება, ამიტომ კოდში ცვლილება შეიძლება იყოს მოდელის ცვლილება. ამ ცვლილებამ შესაბამისად უნდა აისახოს პროექტის ყველა სხვა აქტივობაზე.

## განხორციელების მხარდაჭერა

განხორციელების მჭიდროდ მიბმა მოდელთან ჩვეულებრივ მოითხოვს პროგრამული განვითარების ინსტრუმენტებსა და ენებს, რომლებიც მხარს უჭერენ მოდელირების პარადიგმას, მაგალითად, ობიექტზე ორიენტირებულ პროგრამირებას.

ზოგჯერ განსხვავებული მოდელები იქნება გამოყენებული სხვადასხვა ქვესისტემებისთვის მაგრამ მხოლოდ ერთი მოდელი უნდა გამოიყენებოდეს სისტემის კონკრეტულ ნაწილზე, განვითარების ყველა ასპექტში, კოდიდან დაწყებული მოთხოვნების ანალიზამდე.

ერთი მოდელი ამცირებს შეცდომის შანსებს, რადგან დიზაინი ახლა პირდაპირი შედეგია ფრთხილად გააზრებული მოდელისა. დიზაინი, და თავად კოდიც კი, იძენს მოდელის კომუნიკაბელურობას.


### ტეგები

#DDD #DomainDrivenDesign #ModelDrivenDesign #BindingModelAndImplementation #AnalysisModel